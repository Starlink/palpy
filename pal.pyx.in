
# Copyright (C) 2012 Tim Jenness and Science and Technology
# Facilities Council.
# Copyright (C) 2014 Tim Jenness

# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3 of
# the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

cimport cpal

from libc.stdlib cimport malloc, free

cimport numpy as np
import numpy as np

D2PI = cpal.PAL__D2PI
DAS2R = cpal.PAL__DAS2R
DD2R = cpal.PAL__DD2R
DH2R = cpal.PAL__DH2R
DPI = cpal.PAL__DPI
DPIBY2 = cpal.PAL__DPIBY2
DR2AS = cpal.PAL__DR2AS
DR2D = cpal.PAL__DR2D
DR2H = cpal.PAL__DR2H
DR2S = cpal.PAL__DR2S
DS2R = cpal.PAL__DS2R

def palvers():
    """
    versiondict = palvers()

    Returns the version information from the underlying PAL C
    library used to build palpy. Version information is returned in
    a dict with keys:

    verstring : Version in string form, e.g "1.6.2"
    major : Major version number as integer, e.g. 1
    minor : Minor version number as integer, e.g. 6
    patchlevel : Patch level as integer, e.g. 2
    """
    return dict( { "verstring": @VERSTRING@,
                    "major": @MAJOR_VERSION@,
                    "minor": @MINOR_VERSION@,
                    "patchlevel": @PATCH_VERSION@ } )

def addet( double rm, double dm, double eq ):
     """
     (rc, dc) = addet( rm, dm, eq)

     @palAddet@
     """
     cdef double rc
     cdef double dc
     cpal.palAddet( rm, dm, eq, &rc, &dc )
     return ( rc, dc )

def airmas( double zd ):
     """
     airmass = airmas( zd )

     @palAirmas@
     """
     return cpal.palAirmas( zd )

def altaz(double ha, double dec, double phi):
     """
     (az, azd, azdd, el, eld, eldd, pa, pad, padd) = altaz( ha, dec, phi )

     @palAltaz@
     """
     cdef double az
     cdef double azd
     cdef double azdd
     cdef double el
     cdef double eld
     cdef double eldd
     cdef double pa
     cdef double pad
     cdef double padd
     cpal.palAltaz (ha, dec, phi, &az, &azd, &azdd, &el, &eld, &eldd, &pa, &pad, &padd )
     return (az, azd, azdd, el, eld, eldd, pa, pad, padd )

def amp( double ra, double da, double date, double eq):
     """
     (rm, dm) = amp( ra, da, date, eq )

     @palAmp@
     """
     cdef double rm
     cdef double dm
     cpal.palAmp( ra, da, date, eq, &rm, &dm )
     return ( rm, dm )

def ampqk( double ra, double da, np.ndarray[double, ndim=1] amprms not None ):
     """
     (rm, dm) = ampqk( ra, da, amprms )

     @palAmpqk@
     """
     cdef double rm
     cdef double dm
     cdef double camprms[21]
     for i in range(21):
          camprms[i] = amprms[i]
     cpal.palAmpqk( ra, da, camprms, &rm, &dm )
     return (rm, dm)

def aop( double rap, double dap, double date, double dut,
         double elongm, double phim, double hm, double xp,
         double yp, double tdk, double pmb, double rh,
         double wl, double tlr ):
     """
     (aob, zob, hob, dob, rob) = aop( rap, dap, date, dut,
                                      elongm, phim, hm, xp,
                                      yp, tdk, pmb, rh,
                                      wl, tlr )

     @palAop@
     """
     cdef double aob
     cdef double zob
     cdef double hob
     cdef double dob
     cdef double rob
     cpal.palAop( rap, dap, date, dut, elongm, phim, hm,
                  xp, yp, tdk, pmb, rh, wl, tlr,
                  &aob, &zob, &hob, &dob, &rob)
     return (aob, zob, hob, dob, rob )

def aoppa(double date, double dut, double elongm, double phim,
          double hm, double xp, double yp, double tdk, double pmb,
          double rh, double wl, double tlr ):
     """
     aoprms = aoppa( date, dut, elongm, phim, hm, xp, yp,
                     tdk, pmb, rh, wl, tlr )

     @palAoppa@
     """
     cdef double caoprms[14]
     cdef np.ndarray aoprms = np.zeros( [14], dtype=np.float64 )
     cpal.palAoppa( date, dut, elongm, phim, hm, xp, yp, tdk, pmb,
                    rh, wl, tlr, caoprms )
     for i in range(14):
          aoprms[i] = caoprms[i]
     return aoprms

def aoppat( double date, np.ndarray[double, ndim=1] aoprms not None ):
     """
     aoprms_updated = aoppat( date, aoprms )

     @palAoppat@
     """
     # We can either copy the array or modify in place.
     # For now we return a new copy
     cdef double caoprms[14]
     for i in range(14):
          caoprms[i] = aoprms[i]
     cpal.palAoppat( date, caoprms )
     cdef np.ndarray result = np.zeros( [14], dtype=np.float64 )
     for i in range(14):
          result[i] = caoprms[i]
     return result

def aopqk(double rap, double dap, np.ndarray[double, ndim=1] aoprms not None):
    """
    (aob, zob, hob, dob, rob) = aopqk( rap, dap, aoprms )

    @palAopqk@
    """
    cdef double aob
    cdef double zob
    cdef double hob
    cdef double dob
    cdef double rob

    cdef double caoprms[14]
    for i in range(14):
        caoprms[i]=aoprms[i]

    cpal.palAopqk(rap,dap,caoprms,&aob,&zob,&hob,&dob,&rob)

    return (aob,zob,hob,dob,rob)

def aopqkVector(np.ndarray rap, np.ndarray dap, np.ndarray[double, ndim=1] aoprms not None):
    """
    This is just aopqk, except that it accepts a vector of inputs and
    returns a vector of outputs.
    """
    cdef int i
    cdef int length=len(rap)
    cdef np.ndarray aobout = np.zeros(length,dtype=np.float64)
    cdef np.ndarray zobout = np.zeros(length,dtype=np.float64)
    cdef np.ndarray hobout = np.zeros(length,dtype=np.float64)
    cdef np.ndarray dobout = np.zeros(length,dtype=np.float64)
    cdef np.ndarray robout = np.zeros(length,dtype=np.float64)
    cdef double aob
    cdef double zob
    cdef double hob
    cdef double dob
    cdef double rob

    cdef double caoprms[14]
    for i in range(14):
         caoprms[i]=aoprms[i]
    for i in range(length):
         cpal.palAopqk(rap[i],dap[i],caoprms,&aob,&zob,&hob,&dob,&rob)
         aobout[i]=aob
         zobout[i]=zob
         hobout[i]=hob
         dobout[i]=dob
         robout[i]=rob
    return (aobout,zobout,hobout,dobout,robout)

def atmdsp(double tdk, double pmb, double rh, double wl1,
                 double a1, double b1, double wl2):
    """
    (a2, b2) = atmdsp( tdk, pmb, rh, wl1, a1, b1, wl2 )

    @palAtmdsp@
    """
    cdef double a2
    cdef double b2
    cpal.palAtmdsp(tdk, pmb, rh, wl1, a1, b1, wl2, &a2, &b2)
    return (a2, b2)

def caldj( int iy, int im, int id ):
     """
     djm = caldj( iy, im, id )

     @palCaldj@

     Raises
     ------
     ValueError if arguments are out of range.
     """
     cdef double djm
     cdef int j
     cpal.palCaldj( iy, im, id, &djm, &j )
     if j==0:
          return djm
     else:
          bad = ""
          if j==-1:
               bad = "year"
          elif j==-2:
               bad = "month"
          else:
               bad = "day"
          raise ValueError( "Julian date not computed. Bad {}".format(bad) )

def cldj( int iy, int im, int id ):
     """
     djm = cldj( iy, im, id )

     @palCldj@

     Raises
     ------
     ValueError if arguments are out of range.
     """
     cdef int j
     cdef double djm
     cpal.palCldj( iy, im, id, &djm, &j )
     if j==0:
          return djm
     else:
          bad = ""
          if j==-1:
               bad = "year"
          elif j==-2:
               bad = "month"
          else:
               bad = "day"
          raise ValueError( "Bad {} argument".format(bad) )

def dafin( string, int ipos ):
     """
     Decode a sexagesimal string into an angle.

       (angle, endpos) = pal.dafin( string, startpos )

     where string is the string to be analyzed, startpos
     is the position in the string to start looking
     (starts at 1), endpos is the position in the string
     after the search and angle is the decoded angle in
     radians.

     A ValueError exception is thrown if no angle can
     be found.

     A ValueError exception is thrown if an angle can
     be located but is numerically out of range.

     The interface for this routine is experimental. In
     particular the startpos and endpos variables need
     some thought. startpos could simply be ignored
     as a python slice would work just as well. endpos
     is useful in that you know where to slice the string
     to continue searching for angles. Zero- versus one-
     based indexing is an issue.
     """
     byte_string = string.encode('ascii')
     cdef char * cstring = byte_string
     cdef int cipos = ipos
     cdef double a
     cdef int j
     cpal.palDafin( cstring, &cipos, &a, &j )
     if j==0:
          return ( a, cipos )
     elif j==1:
          raise ValueError( "No angle could be located in string '{}'".format(string) )
     else:
          bad = "unknown"
          if j==-1:
               bad = "degrees"
          elif j==-2:
               bad = "arcminutes"
          elif j==-3:
               bad = "arcseconds"
          raise ValueError( "Bad {} in input string".format(bad) )

def dat( double dju ):
     """
     deltat = dat( dju )

     @palDat@
     """
     return cpal.palDat( dju )

def dav2m( np.ndarray[double, ndim=1] axvec not None ):
     """
     rmat = dav2m( axvec )

     @palDav2m@
     """
     cdef double c_rmat[3][3]
     cdef double c_axvec[3]
     for i in range(3):
         c_axvec[i] = axvec[i]
     cpal.palDav2m( c_axvec, c_rmat )

     cdef np.ndarray rmat = np.zeros([3,3], dtype=np.float64)
     for i in range(3):
         for j in range(3):
             rmat[i][j] = c_rmat[i][j]
     return rmat

def dbear( double a1, double b1, double a2, double b2 ):
     """
     b = dbear( a1, b1, a2, b2 )

     @palDbear@
     """
     return cpal.palDbear( a1, b1, a2, b2 )

def daf2r( int ideg, int iamin, double asec ):
     """
     ang = daf2r( ideg, iamin, asec )

     @palDaf2r@

     Raises
     ------
     ValueError if the input arguments are out of range.
     """
     cdef double rad
     cdef int j
     cpal.palDaf2r( ideg, iamin, asec, &rad, &j )
     if j==0:
          return rad
     else:
          bad = ""
          if j==1:
               bad = "Degree argument outside range 0-369"
          elif j==2:
               bad = "Minute argument outside range 0-59"
          else:
               bad = "Arcsec argument outside range 0-59.9999..."
          raise ValueError( bad )

def dcc2s( np.ndarray[double, ndim=1] v not None ):
     """
     (a, b) = dcc2s( v )

     @palDcc2s@
     """
     cdef double cv[3]
     for i in range(3):
          cv[i] = v[i]
     cdef double a
     cdef double b
     cpal.palDcc2s( cv, &a, &b )
     return (a, b)

def dcs2c( double a, double b ):
     """
     v = dcs2c( a, b )

     @palDcs2c@
     """
     cdef double cv[3]
     cpal.palDcs2c( a, b, cv )
     cdef np.ndarray v = np.zeros( [3], dtype=np.float64 )
     for i in range(3):
          v[i] = cv[i]
     return v

def dd2tf( int ndp, double days ):
     """
     (sign, ih, im, is, frac) = dd2tf( ndp, days )

     @palDd2tf@
     """
     cdef char * csign = " "
     cdef int ihmsf[4]
     cpal.palDd2tf( ndp, days, csign, ihmsf )
     sign = csign.decode('UTF-8')
     return ( sign, ihmsf[0], ihmsf[1], ihmsf[2], ihmsf[3] )

def de2h( double ha, double dec, double phi ):
     """
     (az, el) = de2h( ha, dec, phi )

     @palDe2h@
     """
     cdef double az
     cdef double el
     cpal.palDe2h( ha, dec, phi, &az, &el )
     return (az, el)

def de2hVector( np.ndarray ha, np.ndarray dec, double phi ):
     """
     This isjust de2h, except that it accepts a vector of inputs
     and returns a vector of outputs
     """
     cdef int i
     cdef int length=len(ha)
     cdef np.ndarray azout = np.zeros(length,dtype=np.float64)
     cdef np.ndarray elout = np.zeros(length,dtype=np.float64)
     cdef double az
     cdef double el
     for i in range(length):
          cpal.palDe2h( ha[i], dec[i], phi, &az, &el )
          azout[i]=az
          elout[i]=el
     return (azout, elout)



def deuler( order, double phi, double theta, double psi ):
    """
    rmat = deuler( order, phi, theta, psi )

    @palDeuler@
    """
    cdef double c_rmat[3][3]
    byte_order = order.encode('ascii')
    cdef char * c_order = byte_order
    cpal.palDeuler( c_order, phi, theta, psi, c_rmat )
    cdef np.ndarray rmat = np.zeros([3,3], dtype=np.float64)
    for i in range(3):
        for j in range(3):
            rmat[i][j] = c_rmat[i][j]
    return rmat

# dfltin() not implemented -- not necessary for python

def dh2e( double az, double el, double phi ):
     """
     (ha, dec) = dh2e( az, el, phi )

     @palDh2e@
     """
     cdef double ha
     cdef double dec
     cpal.palDh2e( az, el, phi, &ha, &dec )
     return (ha, dec)

def dimxv( np.ndarray[double, ndim=2] dm not None, np.ndarray[double, ndim=1] va not None):
     """
     vb = dimxv( dm, va )

     @palDimxv@
     """
     cdef double c_dm[3][3]
     cdef double c_va[3]
     cdef double c_vb[3]
     for i in range(3):
          for j in range(3):
                c_dm[i][j] = dm[i][j]
          c_va[i] = va[i]
     cpal.palDimxv(c_dm, c_va, c_vb)

     cdef np.ndarray vb = np.zeros([3], dtype=np.float64)
     for i in range(3):
          vb[i] = c_vb[i]
     return vb

def djcal( int ndp, double djm ):
     """
     (iy, im, id, frac) = djcal( ndp, djm )

     @palDjcal@

     Raises
     ------
     ValueError for unacceptable dates.
     """
     cdef int iymdf[4]
     cdef int j
     cpal.palDjcal( ndp, djm, iymdf, &j )
     if j==0:
          return ( iymdf[0], iymdf[1], iymdf[2], iymdf[3] )
     else:
          raise ValueError( "Unacceptable date" )

def djcl( double djm ):
     """
     (iy, im, id, frac) = djcl( djm )

     @palDjcl@

     Raises
     ------
     ValueError for unacceptable date.
     """
     cdef int iy
     cdef int im
     cdef int id
     cdef double fd
     cdef int j
     cpal.palDjcl( djm, &iy, &im, &id, &fd, &j )
     if j==0:
          return ( iy, im, id, fd )
     else:
          raise ValueError( "Unacceptable date" )

def dmat( np.ndarray[double, ndim=2] a not None,
          np.ndarray[double, ndim=1] y not None ):
     """
     (na, ny, d) = dmat( a, y )

     @palDmat@

     Raises
     ------
     MemoryError: Unable to get workspace

     ArithmeticError: Singular matrix

     ValueError: Shapes of input matrices incompatible
     """
     # validate the arguments and get the dimension
     ashape = a.shape
     yshape = y.shape
     if ashape[0] != ashape[1]:
          raise ValueError( "Matrix must be square" )
     if yshape[0] != ashape[0]:
          raise ValueError( "Matrix must match number of elements in supplied vector" )

     cdef int n = y.size
     cdef int j
     cdef double d
     cdef int *iw = <int *>malloc( n * sizeof(int) )
     cdef double *ca = <double *>malloc( n * n * sizeof(double))
     cdef double *cy = <double *>malloc( n * sizeof(double))

     if not ca or not iw or not cy:
          if ca:
               free(ca)
          if iw:
               free(iw)
          if cy:
               free(cy)
          raise MemoryError( "Could not get dynamic memory for matrix" )

     # Need to flatten the input 2d matrix
     k = 0;
     for i in range(n):
          cy[i] = y[i]
          for j in range(n):
               ca[k] = a[ i, j ]
               k = k + 1

     cpal.palDmat( n, ca, cy, &d, &j, iw )
     free(iw)

     cdef np.ndarray na = np.zeros( [n,n], dtype=np.float64 )
     cdef np.ndarray ny = np.zeros( [n], dtype=np.float64 )

     if j==0:
          k = 0
          for i in range(n):
               ny[i] = cy[i]
               for j in range(n):
                    na[i,j] = ca[k]
                    k = k + 1
          free(ca)
          free(cy)
          return ( na, ny, d )
     else:
          free(ca)
          free(cy)
          raise ArithmeticError( "Matrix is singular" )

def dmoon( double date ):
     """
     pv = dmoon( date )

     @palDmoon@
     """
     cdef double cpv[6]
     cpal.palDmoon( date, cpv )
     cdef np.ndarray pv = np.zeros( [6], dtype=np.float64 )
     for i in range(6):
          pv[i] = cpv[i]
     return pv

def dmxm(np.ndarray[double, ndim=2] a not None, np.ndarray[double, ndim=2] b not None):
    """
    c = dmxm( a, b )

    @palDmxm@
    """
    cdef double c_a[3][3]
    cdef double c_b[3][3]
    cdef double c_c[3][3]
    for i in range(3):
        for j in range(3):
            c_a[i][j] = a[i][j]
            c_b[i][j] = b[i][j]
    cpal.palDmxm(c_a, c_b, c_c)

    cdef np.ndarray c = np.zeros([3,3], dtype=np.float64)
    for i in range(3):
        for j in range(3):
            c[i][j] = c_c[i][j]
    return c

def dmxv(np.ndarray[double, ndim=2] dm not None, np.ndarray[double, ndim=1] va not None):
     """
     vb = dmxv( dm, va )

     @palDmxv@
     """
     cdef double c_dm[3][3]
     cdef double c_va[3]
     cdef double c_vb[3]
     for i in range(3):
          for j in range(3):
                c_dm[i][j] = dm[i][j]
          c_va[i] = va[i]
     cpal.palDmxv(c_dm, c_va, c_vb)

     cdef np.ndarray vb = np.zeros([3], dtype=np.float64)
     for i in range(3):
          vb[i] = c_vb[i]
     return vb

def dm2av(np.ndarray[double, ndim=2] rmat not None):
    """
    axvec = dm2av( rmat )

    @palDm2av@
    """
    cdef double c_rmat[3][3]
    cdef double c_axvec[3]
    for i in range(3):
        for j in range(3):
            c_rmat[i][j] = rmat[i][j]
    cpal.palDm2av( c_rmat, c_axvec )

    cdef np.ndarray axvec = np.zeros([3], dtype=np.float64)
    for i in range(3):
        axvec[i] = c_axvec[i]
    return axvec

def dpav( np.ndarray[double, ndim=1] v1 not None, np.ndarray[double, ndim=1] v2 not None ):
     """
     pa = dpav( v1, v2 )

     @palDpav@
     """
     cdef double cv1[3]
     cdef double cv2[3]
     cdef double result
     for i in range(3):
          cv1[i] = v1[i]
          cv2[i] = v2[i]
     result = cpal.palDpav( cv1, cv2 )
     return result

def dr2af( int ndp, double angle ):
     """
     (sign, id, im, is, frac) = dr2af( ndp, angle )
     @palDr2af@
     """
     cdef char * csign = " "
     cdef int idmsf[4]
     cpal.palDr2af( ndp, angle, csign, idmsf )
     sign = csign.decode('UTF-8')
     return ( sign, idmsf[0], idmsf[1], idmsf[2], idmsf[3] )

def dr2tf( int ndp, double angle ):
     """
     (sign, ih, im, is, frac) = dr2tf( ndp, angle )
     @palDr2tf@
     """
     cdef char * csign = " "
     cdef int ihmsf[4]
     cpal.palDr2tf( ndp, angle, csign, ihmsf )
     sign = csign.decode('UTF-8')
     return ( sign, ihmsf[0], ihmsf[1], ihmsf[2], ihmsf[3] )

def drange( double angle ):
     """
     a = drange( angle )

     @palDrange@
     """
     return cpal.palDrange( angle )

def dranrm( double angle ):
     """
     a = dranrm( angle )

     @palDranrm@
     """
     return cpal.palDranrm( angle )

def ds2tp( double ra, double dec, double raz, double decz ):
     """
     (xi, eta) = ds2tp( ra, dec, raz, decz )

     @palDs2tp@

     Raises
     ------
     ValueError: Bad input arguments
     """
     cdef double xi
     cdef double eta
     cdef int j
     cpal.palDs2tp( ra, dec, raz, decz, &xi, &eta, &j )
     if j==0:
          return (xi, eta)
     elif j==1:
          raise ValueError( "Star too far from axis" )
     elif j==2:
          raise ValueError( "Antistar on tangent plane" )
     else:
          raise ValueError( "Antistart too far from axis" )

def ds2tpVector( np.ndarray ra, np.ndarray dec, double raz, double decz ):
     """
     This is just ds2tp, except that it takes an array of ra and array
     of dec and calculates xi and eta for each relative to the scalar
     raz and decz
     """
     cdef int i
     cdef int j
     cdef int length=len(ra)
     cdef double xi
     cdef double eta
     cdef np.ndarray xiout=np.zeros(length,dtype=np.float64)
     cdef np.ndarray etaout=np.zeros(length,dtype=np.float64)

     for i in range(length):
          cpal.palDs2tp( ra[i], dec[i], raz, decz, &xi, &eta, &j )
          if j==0:
               xiout[i] = xi
               etaout[i] = eta
          elif j==1:
               raise ValueError( "Star too far from axis" )
          elif j==2:
               raise ValueError( "Antistar on tangent plane" )
          else:
               raise ValueError( "Antistart too far from axis" )

     return xiout, etaout

def dsep( double a1, double b1, double a2, double b2 ):
     """
     s = dsep( a1, b1, a2, b2 )

     @palDsep@
     """
     return cpal.palDsep( a1, b1, a2, b2 )

def dsepVector(np.ndarray a1, np.ndarray b1, np.ndarray a2, np.ndarray b2):
     """
     this is dsep but it accepts and returns vectors
     """
     cdef int length=len(a1)
     cdef np.ndarray dd = np.zeros(length, dtype=np.float64)
     cdef double d
     cdef int i
     for i in range(length):
          d = cpal.palDsep(a1[i], b1[i], a2[i], b2[i])
          dd[i] = d
     return dd

def dsepv( np.ndarray[double, ndim=1] v1 not None, np.ndarray[double, ndim=1] v2 not None ):
     """
     s = dsepv( v1, v2 )

     @palDsepv@
     """
     cdef double cv1[3]
     cdef double cv2[3]
     cdef double result
     for i in range(3):
          cv1[i] = v1[i]
          cv2[i] = v2[i]
     result = cpal.palDsepv( cv1, cv2 )
     return result

def dt( double epoch ):
     """
     d = dt( epoch )

     @palDt@
     """
     return cpal.palDt( epoch )

def dtf2d( int ihour, int imin, double sec ):
     """
     days = dtf2d( ihour, imin, sec )

     @palDtf2d@

     Raises
     ------
     ValueError: Arguments out of range.
     """
     cdef double days
     cdef int j
     cpal.palDtf2d( ihour, imin, sec, &days, &j )
     if j==0:
          return days
     else:
          bad = ""
          if j==1:
               bad = "Degree argument outside range 0-369"
          elif j==2:
               bad = "Minute argument outside range 0-59"
          else:
               bad = "Arcsec argument outside range 0-59.9999..."
          raise ValueError( bad )

def dtf2r( int ihour, int imin, double sec ):
     """
     rad = dtf2r( ihour, imin, sec )

     @palDtf2r@

     Raises
     ------
     ValueError: Arguments out of range.
     """
     cdef double rad
     cdef int j
     cpal.palDtf2r( ihour, imin, sec, &rad, &j )
     if j==0:
          return rad
     else:
          bad = ""
          if j==1:
               bad = "Degree argument outside range 0-369"
          elif j==2:
               bad = "Minute argument outside range 0-59"
          else:
               bad = "Arcsec argument outside range 0-59.9999..."
          raise ValueError( bad )

def dtp2s( double xi, double eta, double raz, double decz):
     """
     (ra,dec) = dtp2s( xi, eta, raz, decz )

     @palDtp2s@
     """
     cdef double ra
     cdef double dec
     cpal.palDtp2s( xi, eta, raz, decz, &ra, &dec )
     return (ra,dec)

def dtps2c( double xi, double eta, double ra, double dec ):
     """
     (raz1, decz1, raz2, decz2) = dtps2c( xi, eta, ra, dec )

     @palDtps2c@

     Python notes
     ------------
     If some solutions are missing None is returned for each value.
     """
     cdef double raz1
     cdef double decz1
     cdef double raz2
     cdef double decz2
     cdef int n
     cpal.palDtps2c( xi, eta, ra, dec, &raz1, &decz1, &raz2, &decz2, &n )
     if n==0:
          return (None, None, None, None)
     elif n==1:
          return (raz1, decz1, None, None)
     else:
          return (raz1, decz1, raz2, decz2 )

def dtt( double dju ):
     """
     d = dtt( dju )

     @palDtt@
     """
     return cpal.palDtt( dju )

def dvn( np.ndarray[double, ndim=1] v not None):
    """
    (uv, vm) = dvn( v )

    @palDvn@
    """
    cdef double c_v[3]
    cdef double c_uv[3]
    cdef double vm
    for i in range(3):
        c_v[i] = v[i]
    cpal.palDvn( c_v, c_uv, &vm )

    cdef np.ndarray uv = np.zeros([3], dtype=np.float64)
    for i in range(3):
        uv[i] = c_uv[i]
    return (uv, vm)

def dvxv( np.ndarray[double, ndim=1] va not None, np.ndarray[double, ndim=1] vb not None):
    """
    vc = dvxv( va, vb )

    @palDvxv@
    """
    cdef double c_va[3]
    cdef double c_vb[3]
    cdef double c_vc[3]
    for i in range(3):
        c_va[i] = va[i]
        c_vb[i] = vb[i]
    cpal.palDvxv( c_va, c_vb, c_vc )

    cdef np.ndarray vc = np.zeros([3], dtype=np.float64)
    for i in range(3):
        vc[i] = c_vc[i]
    return vc

def ecleq( double dl, double db, double date ):
     """
     (dr, dd) = eqecl( dl, db, date )

     @palEcleq@
     """
     cdef double dr
     cdef double dd
     cpal.palEcleq( dl, db, date, &dr, &dd )
     return (dr, dd)

def ecmat( double date ):
     """
     rmat = ecmat( date )

     @palEcmat@
     """
     cdef double crmat[3][3]
     cpal.palEcmat( date, crmat )
     cdef np.ndarray rmat = np.zeros( [3,3], dtype=np.float64 )
     for i in range(3):
          for j in range(3):
               rmat[i,j] = crmat[i][j]
     return rmat

def el2ue( double date, int jform, double epoch, double orbinc,
            double anode, double perih, double aorq,  double e,
            double aorl, double dm ):
    """
    u = el2ue( date, jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm )

    @palEl2ue@

    Raises
    ------
    ValueError: Illegal input arguments
    ArithmeticError: Numerical error
    """
    cdef int jstat
    cdef double cu[13]
    cpal.palEl2ue( date, jform, epoch, orbinc, anode, perih, aorq,
                    e, aorl, dm, cu, &jstat )
    if jstat == -1:
        raise ValueError( "Illegal jform" )
    elif jstat == -2:
        raise ValueError( "Illegal e" )
    elif jstat == -3:
        raise ValueError( "Illegal aorq" )
    elif jstat == -4:
        raise ValueError( "Illegal dm" )
    elif jstat == -5:
        raise ArithmeticError( "Numerical error" )

    cdef np.ndarray u = np.zeros( [13], dtype=np.float64 )
    for i in range(13):
        u[i] = cu[i]
    return u

def epb( double date ):
     """
     e = epb( date )

     @palEpb@
     """
     return cpal.palEpb(date)

def epb2d( double epb ):
     """
     d = epb2d( epb )

     @palEpb2d@
     """
     return cpal.palEpb2d(epb)

def epco( k0, k, double e ):
     """
     e = epco( k0, k, e )

     @palEpco@
     """
     k0_bytes = k0.encode('ascii')
     k_bytes = k.encode('ascii')
     cdef char * ck0 = k0_bytes
     cdef char * ck = k_bytes
     return cpal.palEpco( ck0[0], ck[0], e )

def epj( double date ):
     """
     e = epj( date )

     @palEpj@
     """
     return cpal.palEpj(date)

def epj2d( double epj ):
     """
     d = epj2d( epj )

     @palEpj2d@
     """
     return cpal.palEpj2d(epj)

# epv goes here
def epv( double date ):
    """
    (ph, vh, pb, vb) = epv( date )

    @palEpv@
    """
    cdef double cph[3]
    cdef double cvh[3]
    cdef double cpb[3]
    cdef double cvb[3]
    cpal.palEpv( date, cph, cvh, cpb, cvb )

    cdef np.ndarray ph = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray vh = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray pb = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray vb = np.zeros( [3], dtype=np.float64 )
    for i in range(3):
        ph[i] = cph[i]
        vh[i] = cvh[i]
        pb[i] = cpb[i]
        vb[i] = cvb[i]
    return (ph, vh, pb, vb)

def eqecl( double dr, double dd, double date ):
     """
     (dl, db) = eqecl( dr, dd, date )

     @palEqecl@
     """
     cdef double dl
     cdef double db
     cpal.palEqecl( dr, dd, date, &dl, &db )
     return (dl, db)

def eqeqx( double date ):
     """
     eq = eqeqx( date )

     @palEqeqx@
     """
     return cpal.palEqeqx( date )

def eqeqxVector(np.ndarray date):
     """
     this is eqeqx except that it accepts and returns vectors
     """
     cdef int length=len(date)
     cdef np.ndarray eqout = np.zeros(length, dtype=np.float64)
     cdef double eq
     cdef int i
     for i in range(length):
          eq = cpal.palEqeqx(date[i])
          eqout[i] = eq
     return eqout

def eqgal( double dr, double dd ):
     """
     (dl, dd) = eqgal( dr, dd )

     @palEqgal@
     """
     cdef double dl
     cdef double db
     cpal.palEqgal( dr, dd, &dl, &db )
     return (dl, db)

def eqgalVector(np.ndarray dr, np.ndarray dd):
     """
     This is the same as eqgal, but it accepts and returns vectors
     """

     cdef int length=len(dr)
     cdef np.ndarray dlout = np.zeros(length, dtype=np.float64)
     cdef np.ndarray dbout = np.zeros(length, dtype=np.float64)
     cdef double dl
     cdef double db

     for i in range(length):
         cpal.palEqgal(dr[i], dd[i], &dl, &db)
         dlout[i] = dl
         dbout[i] = db

     return (dlout, dbout)

def etrms( double ep ):
     """
     ev = etrms( ep )

     @palEtrms@
     """
     cdef double cev[3]
     cpal.palEtrms( ep, cev )
     cdef np.ndarray ev = np.zeros( [3], dtype=np.float64 )
     for i in range(3):
          ev[i] = cev[i]
     return ev

def evp(double date, double deqx):
    """
    (dvb, dpb, dvh, dph) = evp( date, deqx )

    @palEvp@
    """
    cdef double cdvb[3]
    cdef double cdpb[3]
    cdef double cdvh[3]
    cdef double cdph[3]
    cpal.palEvp( date, deqx, cdvb, cdpb, cdvh, cdph )

    cdef np.ndarray dvb = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray dpb = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray dvh = np.zeros( [3], dtype=np.float64 )
    cdef np.ndarray dph = np.zeros( [3], dtype=np.float64 )
    for i in range(3):
        dvb[i] = cdvb[i]
        dpb[i] = cdpb[i]
        dvh[i] = cdvh[i]
        dph[i] = cdph[i]
    return (dvb, dpb, dvh, dph)

def fk45z( double r1950, double d1950, double bepoch ):
     """
     (r2000, d2000) = fk45z( r1950, d1950, bepoch )

     @palFk45z@
     """
     cdef double r2000
     cdef double d2000
     cpal.palFk45z( r1950, d1950, bepoch, &r2000, &d2000 )
     return (r2000, d2000)

def fk524( double r2000, double d2000, double dr2000,
           double dd2000, double p2000, double v2000 ):
     """
     (r1950, d1950, dr1950, dd1950, p1950, v1950) = fk524( r2000, d2000, dr2000, dd2000, p2000, v2000 )

     @palFk524@
     """
     cdef double r1950
     cdef double d1950
     cdef double dr1950
     cdef double dd1950
     cdef double p1950
     cdef double v1950
     cpal.palFk524( r2000, d2000, dr2000, dd2000, p2000, v2000,
                    &r1950, &d1950, &dr1950, &dd1950,
                    &p1950, &v1950 )
     return (r1950, d1950, dr1950, dd1950, p1950, v1950 )

def fk54z(double r2000, double d2000, double bepoch):
     """
     (r1950, d1950, dr1950, dd1950) = fk54z( r2000, d2000, bepoch )

     @palFk54z@
     """
     cdef double r1950
     cdef double d1950
     cdef double dr1950
     cdef double dd1950
     cpal.palFk54z( r2000, d2000, bepoch, &r1950, &d1950,
                    &dr1950, &dd1950 )
     return (r1950, d1950, dr1950, dd1950 )

def fk5hz( double r5, double d5, double epoch):
     """
     (rh, dh) = fk5hz( r5, d5, epoch )

     @palFk5hz@
     """
     cdef double rh
     cdef double dh
     cpal.palFk5hz( r5, d5, epoch, &rh, &dh )
     return (rh, dh)

def galeq( double dl, double db ):
     """
     (dr, dd) = galeq( dl, db )

     @palGaleq@
     """
     cdef double dr
     cdef double dd
     cpal.palGaleq( dl, db, &dr, &dd )
     return (dr, dd)

def galeqVector(np.ndarray dl, np.ndarray db):
     """
     this is galeq, but it accepts and returns vectors
     """
     cdef int length=len(dl)
     cdef np.ndarray drout = np.zeros(length, dtype=np.float64)
     cdef np.ndarray ddout = np.zeros(length, dtype=np.float64)
     cdef double dr
     cdef double dd
     cdef int i
     for i in range(length):
          cpal.palGaleq(dl[i], db[i], &dr, &dd)
          drout[i] = dr
          ddout[i] = dd
     return (drout, ddout)

def galsup( double dl, double db ):
     """
     (dsl, dsb) = galsup( dl, db )

     @palGalsup@
     """
     cdef double dsl
     cdef double dsb
     cpal.palGalsup( dl, db, &dsl, &dsb )
     return (dsl, dsb)

def ge50( double dl, double db ):
     """
     (rd, dd) = ge50( dl, db )

     @palGe50@
     """
     cdef double dr
     cdef double dd
     cpal.palGe50( dl, db, &dr, &dd )
     return (dr, dd)

def geoc( double p, double h ):
     """
     (r, z) = geoc( p, h )

     @palGeoc@
     """
     cdef double r
     cdef double z
     cpal.palGeoc( p, h, &r, &z )
     return (r, z)

def gmst( double ut1 ):
     """
     t = gmst( ut1 )

     @palGmst@
     """
     return cpal.palGmst( ut1 )

def gmstVector(np.ndarray ut1):
     """
     this is gmst, except that it accepts and returns vectors
     """
     cdef int length = len(ut1)
     cdef np.ndarray gmout = np.zeros(length, dtype=np.float64)
     cdef double gm
     cdef int i
     for i in range(length):
          gm = cpal.palGmst(ut1[i])
          gmout[i] = gm
     return gmout

def gmsta( double date, double ut1 ):
     """
     t = gmsta( date, ut1 )

     @palGmsta@
     """
     return cpal.palGmsta( date, ut1 )

def hfk5z( double rh, double dh, double epoch ):
     """
     (r5, d5, dr5, dd5) = hfk5z( rh, dh, epoch )

     @palHfk5z@
     """
     cdef double r5
     cdef double d5
     cdef double dr5
     cdef double dd5
     cpal.palHfk5z( rh, dh, epoch, &r5, &d5, &dr5, &dd5 )
     return (r5, d5, dr5, dd5)

# We need to return the sign in order to work out whether -0
# is a negative integer (important when parsing "-0 22 33.0"
# sexagesimal format. I'm assuming that no-one is going to really
# use the intin() function.
# We also need to handle overflow. If we raise an exception on
# overflow we can't continue to traverse the string so we have
# to return the position to continue but then document the
# magic value of LONG_MAX and LONG_MIN somehow but where would
# that go? For now raise an exception.
def intin( string, int nstrt ):
     """
     (ireslt, nstrt, sign) = intin( string, nstrt )

     @palIntin@

     Raises
     ------
     OverflowError: Integer too large to fit in 32-bit integer
     """
     cdef long ireslt
     cdef int j
     string_bytes = string.encode('ascii')
     cdef char * cstring = string_bytes
     cpal.palIntin( cstring, &nstrt, &ireslt, &j)
     sign = 0
     if j==0:
          sign = 1
     elif j==-1:
          sign = -1
     elif j==1:
          return (None, nstrt, None)
     else:
          raise OverflowError( "Integer too large for pal.intin() function" )
     return ( ireslt, nstrt, sign )

def map(double rm, double dm, double pr, double pd, double px, double rv, double eq, double date ):
     """
     (ra, da) = map( rm, dm, pr, pd, px, rv, eq, date )

     @palMap@
     """
     cdef double ra
     cdef double da
     cpal.palMap( rm, dm, pr, pd, px, rv, eq, date, &ra, &da )
     return (ra, da)

def mappa( double eq, double date ):
     """
     amprms = mappa( eq, date )

     @palMappa@
     """
     cdef double camprms[21]
     cdef np.ndarray amprms = np.zeros( [21], dtype=np.float64 )
     cpal.palMappa( eq, date, camprms )
     for i in range(21):
          amprms[i] = camprms[i]
     return amprms

def mapqk( double rm, double dm, double pr, double pd, double px, double rv, np.ndarray[double, ndim=1] amprms not None):
     """
     (ra, da) = mapqk( rm, dm, pr, pd, px, rv, amprms )

     @palMapqk@
     """
     cdef double ra
     cdef double da
     cdef double camprms[21]
     for i in range(21):
          camprms[i] = amprms[i]
     cpal.palMapqk( rm, dm, pr, pd, px, rv, camprms, &ra, &da )
     return (ra, da)

def mapqkVector( np.ndarray rm, np.ndarray dm, np.ndarray pr, np.ndarray pd,
np.ndarray px, np.ndarray rv, np.ndarray[double, ndim=1] amprms not None):
     """
     This is just mapqk except that it accepts a vector of inputs and
     returns a vector of outputs
     """
     cdef int i
     cdef int length=len(rm)
     cdef np.ndarray raout=np.zeros(length,dtype=np.float64)
     cdef np.ndarray decout=np.zeros(length,dtype=np.float64)
     cdef double ra
     cdef double da
     cdef double camprms[21]
     for i in range(21):
          camprms[i] = amprms[i]
     for i in range(length):
         cpal.palMapqk( rm[i], dm[i], pr[i], pd[i], px[i], rv[i], camprms, &ra, &da )
         raout[i]=ra
         decout[i]=da

     return (raout, decout)

def mapqkz( double rm, double dm, np.ndarray[double, ndim=1] amprms not None):
     """
     (ra, da) = mapqkz( rm, dm, amprms )

     @palMapqkz@
     """
     cdef double ra
     cdef double da
     cdef double camprms[21]
     for i in range(21):
          camprms[i] = amprms[i]
     cpal.palMapqkz( rm, dm, camprms, &ra, &da )
     return (ra, da)


def mapqkzVector( np.ndarray rm, np.ndarray dm, np.ndarray[double, ndim=1] amprms not None):
     """
     This is just mapqkz except that it accepts a vector of inputs
     and returns a vector of outputs
     """
     cdef int i
     cdef int length=len(rm)
     cdef np.ndarray raout=np.zeros(length,dtype=np.float64)
     cdef np.ndarray decout=np.zeros(length,dtype=np.float64)
     cdef double ra
     cdef double da
     cdef double camprms[21]
     for i in range(21):
          camprms[i] = amprms[i]
     for i in range(length):
          cpal.palMapqkz( rm[i], dm[i], camprms, &ra, &da )
          raout[i]=ra
          decout[i]=da
     return (raout, decout)

def nut( double date ):
     """
     rmatn = nut( date )

     @palNut@
     """
     cdef double crmatn[3][3]
     cpal.palNut( date, crmatn )
     cdef np.ndarray rmatn = np.zeros( [3,3], dtype=np.float64 )
     for i in range(3):
          for j in range(3):
               rmatn[i,j] = crmatn[i][j]
     return rmatn

def nutc( double date):
     """
     (dpsi, deps, eps0) = nutc( date )

     @palNutc@
     """
     cdef double dpsi
     cdef double deps
     cdef double eps0
     cpal.palNutc( date, &dpsi, &deps, &eps0 )
     return (dpsi, deps, eps0)

def oap( type, double ob1, double ob2, double date,
         double dut, double elongm, double phim, double hm,
         double xp, double yp, double tdk, double pmb,
         double rh, double wl, double tlr ):
     """
     (rap, dap) = oap( ob1, ob2, date, dut, elongm, phim,
                    hm, xp, yp, tdk, pmb, rh, wl, tlr )

     @palOap@
     """
     cdef double rap
     cdef double dap
     byte_string = type.encode('ascii')
     cdef char * ctype = byte_string
     cpal.palOap( ctype, ob1, ob2, date, dut, elongm, phim,
                  hm, xp, yp, tdk, pmb, rh, wl, tlr, &rap, &dap )
     return ( rap, dap )

def oapqk( type, double ob1, double ob2, np.ndarray[double, ndim=1] aoprms not None ):
     """
     (rap, dap) = oapqk( type, ob1, ob2, aoprms )

     @palOapqk@
     """
     cdef double rap
     cdef double dap
     byte_string = type.encode('ascii')
     cdef char * ctype = byte_string
     cdef double caoprms[14]
     for i in range(14):
          caoprms[i] = aoprms[i]
     cpal.palOapqk( ctype, ob1, ob2, caoprms, &rap, &dap )
     return ( rap, dap )

# Numeric lookup is only useful when scanning through the
# list of telescopes. The python interface does not need this.
# Instead obs() returns a dict (which may be a bit less efficient
# than an iterable but it's easy) with a dict inside. No arguments.
def obs():
     """
     telescopes = pal.obs()

     Obtain telescope parameters.

     Returns a dict with keys corresponding to the short
     name of the telescope. The corresponding value is itself
     a dict with keys:

     name: long name of the telescope
     long: west longitude (radians)
     lat: geodetic latitude (radians)
     height: Height above sea level (metres)
     """
     cdef int n = 1
     cdef char c
     cdef char cident[11]
     cdef char cname[41]
     cdef double w
     cdef double p
     cdef double h
     cdef int retval = 0

     result = {}

     while True:
          retval = cpal.palObs( n, &c, cident, 11, cname, 41,
                                &w, &p, &h )
          n=n+1 # Next telescope

          if retval != 0:
               break
          newtel = { 'name': cname.decode('UTF-8'),
                     'long': w,
                     'lat': p,
                     'height': h }
          result[cident.decode('UTF-8')] = newtel

     return result

def pa( double ha, double dec, double phi):
     """
     a = pa( ha, dec, phi )

     @palPa@
     """
     return cpal.palPa( ha, dec, phi )

def pcd( double disco, double x, double y):
    """
    (cx, cy) = pcd( x, y )

    Returns the distorted coordinates and does not
    modify the supplied arguments.

    @palPcd@
    """
    cpal.palPcd( disco, &x, &y )
    return (x, y)

def polmo( double elongm, double phim, double xp, double yp):
    """
    (elong, phi, daz) = polmo( elongm, phim, xp, yp )

    @palPolmo@
    """
    cdef double elong
    cdef double phi
    cdef double daz

    cpal.palPolmo( elongm, phim, xp, yp, &elong, &phi, &daz )

    return (elong, phi, daz)

def pertel(int jform, double date0, double date1,
            double epoch0, double orbi0, double anode0,
            double perih0, double aorq0, double e0, double am0):
    """
    (epoch1, orbi1, anode1, perih1, aorq1, e1, am1) = pertel( jform, date0, date1,
                                                            epoch0, orbi0, anode0, perih0,
                                                            aorq0, e0, am0 )

    @palPertel@

    Raises
    ------
    ValueError: Illegal input arguments.
    ArithmeticError: Internal error.
    """
    cdef double epoch1
    cdef double orbi1
    cdef double anode1
    cdef double perih1
    cdef double aorq1
    cdef double e1
    cdef double am1
    cdef int jstat

    cpal.palPertel( jform, date0, date1,
                    epoch0, orbi0, anode0, perih0, aorq0, e0, am0,
                    &epoch1, &orbi1, &anode1, &perih1, &aorq1, &e1, &am1,
                    &jstat )
    if jstat == -1:
        raise ValueError( "Illegal jform" )
    elif jstat == -2:
        raise ValueError( "Illegal e0" )
    elif jstat == -3:
        raise ValueError( "Illegal aorq0" )
    elif jstat == -4:
        raise ArithmeticError( "Internal error" )
    elif jstat == -5:
        raise ArithmeticError( "Numerical error" )

    return ( epoch1, orbi1, anode1, perih1, aorq1, e1, am1 )

def pertue( double date, np.ndarray[double, ndim=1] u not None ):
    """
    u2 = pertue( date, u )

    @palPertue@

    Raises
    ------
    ArithmeticError: Numerical error
    """
    cdef double cu[13]
    cdef int jstat

    for i in range(13):
        cu[i] = u[i]

    cpal.palPertue( date, cu, &jstat )

    if jstat == -1:
        raise ArithmeticError( "Numerical error" )

    # We return the modified U and do not change in place
    cdef np.ndarray u2 = np.zeros( [13], dtype=np.float64)
    for i in range(13):
        u2[i] = cu[i]
    return u2

def planel( double date, int jform, double epoch, double orbinc,
            double anode, double perih, double aorq,  double e,
            double aorl, double dm ):
    """
    pv = planel( date, jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm )

    @palPlanel@

    Raises
    ------
    ValueError: Illegal input arguments
    ArithmeticError: Numerical error
    """
    cdef int jstat
    cdef double cpv[6]
    cpal.palPlanel( date, jform, epoch, orbinc, anode, perih, aorq,
                    e, aorl, dm, cpv, &jstat )
    if jstat == -1:
        raise ValueError( "Illegal jform" )
    elif jstat == -2:
        raise ValueError( "Illegal e" )
    elif jstat == -3:
        raise ValueError( "Illegal aorq" )
    elif jstat == -4:
        raise ValueError( "Illegal dm" )
    elif jstat == -5:
        raise ArithmeticError( "Numerical error" )

    cdef np.ndarray pv = np.zeros( [6], dtype=np.float64 )
    for i in range(6):
        pv[i] = cpv[i]
    return pv

def planet( double date, int planetnum ):
    """
    pv = planet( date, planetnum )

    @palPlanet@

    Raises
    ------
    ValueError: Illegal planet number
    ArithmeticError: Solution did not converge
    """
    cdef int jstat
    cdef double cpv[6]
    cpal.palPlanet( date, planetnum, cpv, &jstat )
    if jstat == -2:
        raise ArithmeticError( "Solution didn't converge" )
    elif jstat == -1:
        raise ValueError( "Illegal planet number "+str(planetnum)+", must be in range (1-8)" )

    cdef np.ndarray pv = np.zeros( [6], dtype=np.float64 )
    for i in range(6):
        pv[i] = cpv[i]
    return pv

def plante( double date, double elong, double phi, int jform,
            double epoch, double orbinc, double anode, double perih,
            double aorq, double e, double aorl, double dm ):
    """
    (ra, dec, r) = plante( date, elong, phi, jform, epoch, orbinc, anode,
                           perih, aorq, e, aorl, dm )

    @palPlante@

    Raises
    ------
    ValueError: Illegal arguments
    ArithmeticError: Numerical error
    """
    cdef double ra
    cdef double dec
    cdef double r
    cdef int jstat

    cpal.palPlante(date, elong, phi, jform, epoch, orbinc, anode, perih, aorq,e, aorl, dm, &ra, &dec, &r, &jstat)
    if jstat == -1:
        raise ValueError( "Illegal jform" )
    elif jstat == -2:
        raise ValueError( "Illegal e" )
    elif jstat == -3:
        raise ValueError( "Illegal aorq" )
    elif jstat == -4:
        raise ValueError( "Illegal dm" )
    elif jstat == -5:
        raise ArithmeticError( "Numerical error" )
    return (ra, dec, r)

def plantu( double date, double elong, double phi, np.ndarray[double, ndim=1] u not None):
    """
    (ra, dec, r) = plantu( date, elong, phi, u )

    @palPlantu@

    Raises
    ------
    ValueError: Radius vector zero
    Arithmetic Error: Failed to converge
    """
    cdef double ra
    cdef double dec
    cdef double r
    cdef int jstat
    cdef double cu[13]

    for i in range(13):
        cu[i] = u[i]
    cpal.palPlantu( date, elong, phi, cu, &ra, &dec, &r, &jstat )
    if jstat == -1:
        raise ValueError( "Radius vector zero" )
    elif jstat == -2:
        raise ArithmeticError( "Failed to converge" )
    return (ra, dec, r )

def pm( double r0, double d0, double pr, double pd,
        double px, double rv, double ep0, double ep1 ):
     """
     (r1, d1) = pm( r0, d0, pr, pd, px, rv, ep0, ep1 )

     @palPm@
     """
     cdef double r1
     cdef double d1
     cpal.palPm( r0, d0, pr, pd, px, rv, ep0, ep1, &r1, &d1 )
     return (r1, d1)

def pmVector( np.ndarray r0, np.ndarray d0, np.ndarray pr,
     np.ndarray pd, np.ndarray px, np.ndarray rv, double ep0,
     double ep1):
     """
     This is pm (see above), except that it accepts an
     ndarray of values for each argument
     """

     cdef int i
     cdef int length=len(r0)
     cdef np.ndarray r1out=np.zeros(length,dtype=np.float64)
     cdef np.ndarray d1out=np.zeros(length,dtype=np.float64)
     cdef double r1
     cdef double d1

     for i in range(length):
          cpal.palPm(r0[i],d0[i],pr[i],pd[i],px[i],rv[i],ep0,ep1,&r1,&d1)
          r1out[i]=r1
          d1out[i]=d1

     return(r1out,d1out)

def prebn( double bep0, double bep1 ):
     """
     rmatp = prebn( bep0, bep1 )

     @palPrebn@
     """
     cdef double crmatp[3][3]
     cpal.palPrebn( bep0, bep1, crmatp )
     cdef np.ndarray rmatp = np.zeros( [3,3], dtype=np.float64 )
     for i in range(3):
          for j in range(3):
               rmatp[i,j] = crmatp[i][j]
     return rmatp

def prec( double ep0, double ep1 ):
     """
     rmatp = prec( ep0, ep1 )

     @palPrec@
     """
     cdef double crmatp[3][3]
     cpal.palPrec( ep0, ep1, crmatp )
     cdef np.ndarray rmatp = np.zeros( [3,3], dtype=np.float64 )
     for i in range(3):
          for j in range(3):
               rmatp[i,j] = crmatp[i][j]
     return rmatp

def preces( sys, double ep0, double ep1, double ra, double dc ):
     """
     (ra, dc) = preces( sys, ep0, ep1, ra, dec)

     @palPreces@
     """
     byte_string = sys.encode('ascii')
     cdef char * csys = byte_string
     cpal.palPreces( csys, ep0, ep1, &ra, &dc )
     return (ra, dc)

def prenut( double epoch, double date):
    """
    rmatpn = prenut( epoch, date )

    @palPrenut@
    """
    cdef double crmatpn[3][3]
    cpal.palPrenut( epoch, date, crmatpn )
    cdef np.ndarray rmatpn = np.zeros( [3,3], dtype=np.float64 )
    for i in range(3):
        for j in range(3):
            rmatpn[i,j]=crmatpn[i][j]
    return rmatpn

def pv2el(np.ndarray[double, ndim=1] pv not None, double date, double pmass, int jformr):
    """
    (jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm) = pv2el( pv, date, pmass, jformr )

    @palPv2el@

    Raises
    ------
    ValueError: Illegal arguments
    """
    cdef int jform
    cdef double epoch
    cdef double orbinc
    cdef double anode
    cdef double perih
    cdef double aorq
    cdef double e
    cdef double aorl
    cdef double dm
    cdef int jstat
    cdef double cpv[6]

    for i in range(6):
        cpv[i] = pv[i]
    cpal.palPv2el( cpv, date, pmass, jformr, &jform, &epoch, &orbinc, &anode, &perih,
                   &aorq, &e, &aorl, &dm, &jstat )
    if jstat == -1:
        raise ValueError( "Illegal PMASS" )
    elif jstat == -2:
        raise ValueError( "Illegal JFORMR" )
    elif jstat == -3:
        raise ValueError( "Position/velocity out of range" )
    return (jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm)

def pv2ue( np.ndarray[double, ndim=1] pv not None, double date, double pmass ):
    """
    u = pv2ue( pv, date, pmass )

    @palPv2ue@

    Raises
    ------
    ValueError: Illegal arguments
    """
    cdef int jstat
    cdef double cu[13]
    cdef double cpv[6]

    for i in range(6):
        cpv[i] = pv[i]
    cpal.palPv2ue( cpv, date, pmass, cu, &jstat )
    if jstat == -1:
        raise ValueError( "Illegal PMASS" )
    elif jstat == -2:
        raise ValueError( "Too close to Sun" )
    elif jstat == -3:
        raise ValueError( "Too slow" )

    cdef np.ndarray u = np.zeros( [13], dtype=np.float64 )
    for i in range(13):
        u[i] = cu[i]
    return u

def pvobs( double p, double h, double stl ):
     """
     pv = pvobs( p, h, stl )

     @palPvobs@
     """
     cdef double cpv[6]
     cpal.palPvobs( p, h, stl, cpv )
     cdef np.ndarray pv = np.zeros( [6], dtype=np.float64 )
     for i in range(6):
          pv[i] = cpv[i]
     return pv

def rdplan( double date, int np, double elong, double phi ):
    """
    (ra, dec, diam) = rdplan( date, np, elong, phi )

    @palRdplan@
    """
    cdef double ra
    cdef double dec
    cdef double diam
    cpal.palRdplan( date, np, elong, phi, &ra, &dec, &diam )
    return (ra, dec, diam)

def refco( double hm, double tdk, double pmb, double rh, double wl, double phi, double tlr, double eps):
    """
    (refa, refb) = refco( hm, tdk, pmb, rh, wl, phi, tlr, eps )

    @palRefco@
    """
    cdef double refa
    cdef double refb
    cpal.palRefco(hm,tdk,pmb,rh,wl,phi,tlr,eps,&refa,&refb)
    return (refa,refb)

def refcoq( double tdk, double pmb, double rh, double wl):
    """
    (refa, refb) = refcoq( tdk, pmb, rh, wl )

    @palRefcoq@
    """
    cdef double refa
    cdef double refb
    cpal.palRefcoq( tdk, pmb, rh, wl, &refa, &refb )
    return (refa, refb)

def refro( double zobs, double hm, double tdk, double pmb,
           double rh, double wl, double phi, double tlr, double eps):
    """
    ref = refro( zobs, hm, tdk, pmb, rh, wl, phi, tlr, eps )

    @palRefro@
    """
    cdef double ref
    cpal.palRefro(zobs, hm, tdk, pmb, rh, wl, phi, tlr, eps, &ref)
    return ref

def refv( np.ndarray[ double, ndim=1] vu not None, double refa, double refb):
    """
    vr = refv( vu, refa, refb )

    @palRefv@
    """
    cdef double cvr[3]
    cdef double cvu[3]
    cdef np.ndarray vr = np.zeros( [3], dtype=np.float64)
    for i in range(3):
        cvu[i] = vu[i]
    cpal.palRefv( cvu, refa, refb, cvr )
    for i in range(3):
        vr[i] = cvr[i]
    return vr

def refz( double zu, double refa, double refb ):
    """
    zr = refz( zu, refa, refb )

    @palRefz@
    """
    cdef double zr
    cpal.palRefz(zu,refa,refb,&zr)
    return zr

def refzVector(np.ndarray zu, double refa, double refb):
     """
     this is just refz, but accepts a vector of zenith distances
     and returns a vector of corrected zenith distances (the refraction
     coefficients must be the same for all of the sources)
     """
     cdef int length = len(zu)
     cdef np.ndarray zrout = np.zeros(length, dtype=np.float64)
     cdef double zr
     cdef int i
     for i in range(length):
          cpal.palRefz(zu[i], refa, refb, &zr)
          zrout[i] = zr
     return zrout

def rverot( double phi, double ra, double da, double st ):
     """
     r = rverot( phi, ra, da, st )

     @palRverot@
     """
     return cpal.palRverot( phi, ra, da, st )

def rvgalc( double r2000, double d2000 ):
     """
     rv = rvgalc( r2000, d2000 )

     @palRvgalc@
     """
     return cpal.palRvgalc( r2000, d2000 )

def rvlg( double r2000, double d2000 ):
     """
     rv = rvlg( r2000, d2000 )

     @palRvlg@
     """
     return cpal.palRvlg( r2000, d2000 )

def rvlsrd( double r2000, double d2000 ):
     """
     rv = rvlsrd( r2000, d2000 )

     @palRvlsrd@
     """
     return cpal.palRvlsrd( r2000, d2000 )

def rvlsrk( double r2000, double d2000 ):
     """
     rv = rvlsrk( r2000, d2000 )

     @palRvlsrk@
     """
     return cpal.palRvlsrk( r2000, d2000 )

def subet( double rc, double dc, double eq ):
     """
     (rm, dm) = subet( rc, dc, eq )

     @palSubet@
     """
     cdef double rm
     cdef double dm
     cpal.palSubet( rc, dc, eq, &rm, &dm )
     return ( rm, dm )

def supgal( double dsl, double dsb ):
     """
     (dl, db) = supgal( dsl, dsb )

     @palSupgal@
     """
     cdef double dl
     cdef double db
     cpal.palSupgal( dsl, dsb, &dl, &db )
     return (dl, db)

def ue2el(np.ndarray[double, ndim=1] u not None, int jformr ):
    """
    (jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm) = ue2el( u, jformr )

    @palUe2el@

    Raises
    ------
    ValueError: Illegal arguments
    """
    cdef int jform
    cdef double epoch
    cdef double orbinc
    cdef double anode
    cdef double perih
    cdef double aorq
    cdef double e
    cdef double aorl
    cdef double dm
    cdef int jstat
    cdef double cu[13]

    for i in range(13):
        cu[i] = u[i]
    cpal.palUe2el( cu, jformr, &jform, &epoch, &orbinc, &anode, &perih,
                   &aorq, &e, &aorl, &dm, &jstat )
    if jstat == -1:
        raise ValueError( "Illegal combined mass" )
    elif jstat == -2:
        raise ValueError( "Illegal jformr" )
    elif jstat == -3:
        raise ValueError( "Position/velocity out of range")
    return (jform, epoch, orbinc, anode, perih, aorq, e, aorl, dm)

#  Note that u is updated and returned
def ue2pv( double date, np.ndarray[double, ndim=1] u not None ):
    """
    (u2, pv) = ue2pv( date, u )

    @palUe2pv@

    Raises
    ------
    ValueError: Radius vector zero
    ArithmeticError: Failed to converge
    """
    cdef double cu[13]
    cdef double cpv[6]
    cdef int jstat

    for i in range(13):
        cu[i] = u[i]
    cpal.palUe2pv( date, cu, cpv, &jstat )
    if jstat == -1:
        raise ValueError( "Radius vector zero" )
    elif jstat == -2:
        raise ArithmeticError( "Failed to converge" )

    # We need to return a completely new updated U
    # rather than overwrite in place
    cdef np.ndarray u2 = np.zeros( [13], dtype=np.float64)
    cdef np.ndarray pv = np.zeros( [6], dtype=np.float64)
    for i in range(13):
        u2[i] = cu[i]
    for i in range(6):
        pv[i] = cpv[i]
    return (u2, pv)

def unpcd( double disco, double x, double y):
    """
    (tx, ty) = unpcd( x, y )

    Returns the tangent plane coordinates and does not
    modify the supplied arguments.

    @palUnpcd@
    """
    cpal.palUnpcd( disco, &x, &y )
    return (x, y)
